{"meta":{"title":"mover's blog","subtitle":null,"description":null,"author":"liu yahui","url":"http://yoursite.com"},"pages":[{"title":"前端兼容性问题与解决","date":"2016-10-06T01:05:55.000Z","updated":"2017-05-19T02:19:17.000Z","comments":true,"path":"前端兼容性问题与解决.html","permalink":"http://yoursite.com/前端兼容性问题与解决.html","excerpt":"","text":"css 1.ie浮动产生的双倍距离 给浮动的元素设置 display：inline-block 4.浏览器的默认的css各有不同，解决办法 设置css的初始样式reset，统一规定 3.背景透明问题 ie:filter:alpha(opacity=0.2)FF: opacity:0.6; 4.min-height最小高度的实现（兼容IE6、IE7、FF） height:auto;min-height:100px; 5.Box阴影(CSS3) .box { box-shadow: 5px 5px 5px #666; -moz-box-shadow: 5px 5px 5px #666; -webkit-box-shadow: 5px 5px 5px #666; } 6.文字与表单对齐方法？ vertical-align:middle 7.文字与图片垂直居中对齐方法？ 图片内嵌在文字里面，给文字设置 vertical-align:middle 8.图片的3像素距离 display：inline-blockjs1.event.x与event.y问题问题说明：IE下，even对象有x、y属性，但是没有pageX、pageY属性；Firefox下，even对象有pageX、pageY属性，但是没有x、y属性。解决方法：var myX = event.x ? event.x : event.pageX; var myY = event.y ? event.y:event.pageY; 2.event.srcElement问题 问题说明：IE下，even对象有srcElement属性，但是没有target属性；Firefox下，even对象有target属性，但是没有srcElement属性。解决方法：使用srcObj = event.srcElement ? event.srcElement : event.target; 3.window.location.href问题 问题说明：IE或者Firefox2.0.x下，可以使用window.location或window.location.href；Firefox1.5.x下，只能使用window.location。解决方法：使用 window.location 来代替 window.location.href。当然也可以考虑使用 location.replace()方法。 4.访问的父元素的区别 问题说明：在IE下，使用 obj.parentElement 或 obj.parentNode 访问obj的父结点；在firefox下，使用 obj.parentNode 访问obj的父结点。解决方法：因为firefox与IE都支持DOM，因此统一使用obj.parentNode 来访问obj的父结点。 5.innerText的问题. 问题说明：innerText在IE中能正常工作，但是innerText在FireFox中却不行。解决方法：在非IE浏览器中使用textContent代替innerText。示例：if(navigator.appName.indexOf(“Explorer”) &gt;-1){document.getElementById(‘element’).innerText = “my text”;} else{document.getElementById(‘element’).textContent = “;my text”;}[注] innerHTML 同时被ie、firefox等浏览器支持，其他的，如outerHTML等只被ie支持，最好不用。"},{"title":"前端面试题","date":"2016-09-08T01:56:00.000Z","updated":"2018-07-11T05:51:03.000Z","comments":true,"path":"前端面试题.html","permalink":"http://yoursite.com/前端面试题.html","excerpt":"","text":"HTML+CSS 1.Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?&lt;!DOCTYPE&gt; 声明位于文档中的最前面，处于标签之前。告知浏览器以何种模式来渲染文档。严格模式的排版和 JS 运作模式是 以该浏览器支持的最高标准运行。在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。2.HTML与XHTML——二者有什么区别所有的标记都必须要有一个相应的结束标记所有标签的元素和属性的名字都必须使用小写所有的XML标记都必须合理嵌套所有的属性必须用引号””括起来把所有&lt;和&amp;特殊符号用编码表示给所有属性赋一个值不要在注释内容中使“–”图片必须有说明文字（标签闭合，标签小写，合理的嵌套）3.什么是语义化的HTML直观的认识标签，去掉或者丢失样式的时候能够让页面呈现出清晰的结构有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。4.对WEB标准以及W3C的理解与认识标签闭合、标签小写、不乱嵌套、提高搜索机器人搜索几率、使用外 链css和js脚本、结构行为表现的分离、文件下载与页面速度更快、内容能被更多的用户所访问、内容能被更广泛的设备所访问、更少的代码和组件，容易维 护、改版方便，不需要变动页面内容、提供打印版本而不需要复制内容、提高网站易用性；5.行内元素有哪些?块级元素有哪些?CSS的盒模型?行内元素：a,i,span,input,select块级元素：p,div,ui,li,h1~h4,form盒模型：内容,padding,border,margin6.CSS引入的方式有哪些? link和@import的区别是?内联 内嵌 外链 导入link属于xhtml标签，而@import是css提供的在页面加载时link会同时被加载，而@import需要页面被加载完成后才加载@import只有在ie5 以上才被识别，而link无兼容性问题7.CSS选择符有哪些?哪些属性可以继承?优先级算法如何计算?内联和important哪个优先级高?id选择符 类选择符 标签选择符id&gt;class&gt;标签选择符import优先级高8.前端页面有哪三层构成，分别是什么?作用是什么?结构层 html表现层 css行为层 js9.css的基本语句构成是?选择器{ 属性1：值1； 属性2：值2； ···}10.你做的页面在哪些流览器测试过?这些浏览器的内核分别是什么ie(trident)火狐(Gecko)谷歌(webkit)opear(Presto)11.标签上title与alt属性的区别是什么?title:为该属性是提供信息alt:图片为加载失败时的文字信息12.描述css reset的作用和用途reset 重置浏览器默认的css的属性，由于浏览器的不同，会有不同是css初始值样式，重置样式，统一样式13.解释css sprites，如何使用。由零散的图片合并成一张大图，减少服务器对图片的请求数量14.浏览器标准模式和怪异模式之间的区别是什么?盒模型 渲染模式不同可以用 window.top.document.compatMode查看是什么模式15.你如何对网站的文件和资源进行优化?期待的解决方案包括：合并文件压缩文件使用缓存使用CDN托管16.简述一下src与href的区别href指向网络资源的位置，用于建立超链接src指向外部资源，请求时下载并嵌入标签内进行应用，例如js脚本，img17.什么是CSS Hack?针对于不同的浏览器用同的css，就是css hackie浏览器一般分为三种css hack：条件hack 属性hack 选择器hack18.简述同步和异步的区别同步为阻塞模式，异步为非阻塞模式同步：一个进程在执行某个请求，这个请求要一段时间才能返回信息，此时需要等待直到有信息的返回，该进程才执行下去异步：是指进程不需要等待，可以一直执行下去，等到有信息返回的时候进程会进行处理，这样可以提高执行效率19.px和em的区别px和em都是长度单位。px是固定的值em是不固定的，继承父元素的字体大小，浏览器默认字体大小是16px20.什么叫优雅降级和渐进增强优雅降级：一开始就构建完整的功能，然后再进行低版本的兼容渐进增强：针对低版本浏览器进行网页的构建，保证最低版本的功能，然后进行高版本浏览器效果，交互等改进和新功能的追加，达到最佳的用户体验。20.HTML5 为什么只需要写 !DOCTYPE HTML？HTML5不是基于SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为，而HTML4.01是基于SGML所以需要引用DTD，才能告知浏览器文档所使用的文档类型。21.请描述一下 cookies，sessionStorage 和 localStorage 的区别？不同:cookie在浏览器和服务器之前来回传递，而sessionStorage和locationStorage不会sessionStorage和locationStorage有独立的存储空间且存储空间更大，有丰富易用的接口。大小不同:cookie 4K Storage 5M有效期不同:cookie过期之前有效sessionStorage仅在浏览器关闭前有效locationStorage始终是有效的作用域不同:sessionStorage在不同浏览器窗口不共享，即使是同一个页面cookie:同源共享locationStorage:同源共享22.如何实现浏览器内多个标签页之间的通信?使用cookie和locationStorage等本地存储方式23.CSS隐藏元素的几种方法（至少说出三种）opacity:占用原本的位置，影响用户的交互visibility:和opacity不同的是不影响用户的交互display:设置none值，效果是不占据位置，子昂是完全不存在一样。24.CSS清除浮动的几种方法（至少两种）给父元素是设置height给父元素添加after伪类给父元素设置overflow：hidden给父元素设置overflow：auto尾部添加空标签div，并设置clear：both25.html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？1.拖拽释放(Drag and drop) API2.语义化更好的内容标签（header,nav,footer,aside,article,section）3.音频、视频API(audio,video)4.画布(Canvas) API5.地理(Geolocation) API6.本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；26.CSS3有哪些新特性border-radius 圆角box-shadow 阴影gradient 渐变transform 旋转等JS1.javascript的typeof返回哪些数据类型?js都有什么数据类型number obj function boolean underfind string5种基本数据类型：underfind、null、boolean、string、number1种特殊类型：object2.例举3种强制类型转换和2种隐式类型转换?强制转换:parseInt parseFloat number隐式转换:- ==3.split() join() 的区别split()是把字符串切割为数组join()是把数组拼接成字符串4.数组方法pop() push() unshift() shift()pop()从数组尾数删除push()从数组尾部增加unshift()从数组的头部增加shift()从数组的尾部删除5.IE和标准下有哪些兼容性的写法var ev = ev || window.eventvar target = ev.srcElement || ev.target6.ajax请求的时候get 和post方式的区别get:将请求的参数加在url尾部，传送体积小，安全性低，通常用于数据的获取post:将请求包含在请求头里，传送的体积较大，由于参数没有暴露在url上，安全性较高，通常用于修改数据7.call和apply的区别obj.call(this,obj1,obg2,···)obj.apply(this,arguments)8.ajax请求时，如何解析json数据parse eval 但是对于parse的安全性更高8.事件委托是什么利用冒泡原理，让自己的触发事件由父元代替执行9.闭包是什么，有什么特性，对页面有什么影响闭包是可以读取其他函数内部变量的函数10.如何阻止事件冒泡和默认事件 function stopBubble(e){ if(e&amp;&amp;e.stopPropagation){ e.stopPropagation(); }else{ window.event.cancelBubble = true } } function stopDefault(e){ if(e&amp;&amp;e.stopDefault){ e.stopDefault() }else{ window.event.returnValue = false } } 11.添加 删除 替换 插入到某个接点的方法obj.appendChild()obj.removeChild()obj.repalceChild()obj.inserBefore() 12.解释jsonp的原理，以及为什么不是真正的ajax动态创建script标签，回调函数Ajax是无需刷新请求数据 13.javascript的本地对象，内置对象和宿主对象本地对象:array obj regexp等可以new的实例化对象内置对象:gload Math 等不可实例化的对象宿主对象:浏览器自带的 window document 等对象 14.document load 和document ready的区别load是结构样式加载完成后再执行jsready不是原生，JQ中有$().ready(function) 15.”==”和“===”的不同前者会自动转换，后者不会 16.javascript的同源策略一段脚本只能读取来自同一源的窗口和文档的属性，这里的同一源指的是主机名，协议和端口的组合 17.怎样创建和查找节点？创建节点createElement()createTextNode()查找节点getElementByTagName()getElementByName()getElementById() 18.如何消除一个数组里面重复的元素？ 19.了解Node么？Node的使用场景都有哪些？高并发 聊天 实时消息推送 20.对于前端自动化构建工具有了解吗？简单介绍一下webpack 21.this对象的理解this总是指向函数的直接调用者如果有关键字new，那就是new出来的那个对象在事件中，this指向触发该事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window 22.null和undefined的区别？null表示为一个“无”的对象，用数值表示为0作为函数的参数，表示该参数不是对象作为对象的原型链的终点 underfind表示一个“无”的原始值，用数字表示为NaN表示变量声明了，但是没有赋值调用函数式，提供的参数没有提供 23.JSON 的了解json是一种轻量级的数据格式，数据格式简单，易于读写，占用宽带小格式：{“age”：“12”，“name”：“lili”} HTTP 一次完整的HTTP事务是怎样的一个过程？域名解析发起TCP3次握手建立TCP连接后，发起http请求服务端响应请求，浏览器得到html代码浏览器解析html代码，并获取html代码中的资源在浏览器中对页面进行渲染 HTTP的状态码有哪些？100-199:指定客户端相应的操作200-299:请求成功300-399:重定向400-499:客户端错误500-599:服务端错误"}],"posts":[{"title":"ES6 学习笔记","slug":"ES6-学习笔记","date":"2018-01-16T12:52:20.000Z","updated":"2018-07-26T13:16:58.000Z","comments":true,"path":"2018/01/16/ES6-学习笔记/","link":"","permalink":"http://yoursite.com/2018/01/16/ES6-学习笔记/","excerpt":"","text":"版权声明：本文为博主原创文章，未经博主允许不得转载。 Let ：声明的变量在所在的块级作用域内有效。 不存在变量提升 （var存在变量提升，声明前调用为undefind，let会报错） 暂时性死区 （在没有声明前，都属于死区，let会报错） 不允许重复声明 （同一作用域不能重复声明，let会报错） ps： for循环的计数器 i 就很适合使用let的命令。","categories":[],"tags":[]},{"title":"webpack笔记","slug":"webpack笔记","date":"2018-01-10T05:41:45.000Z","updated":"2018-03-10T06:42:15.000Z","comments":true,"path":"2018/01/10/webpack笔记/","link":"","permalink":"http://yoursite.com/2018/01/10/webpack笔记/","excerpt":"","text":"版权声明：本文为博主原创文章，未经博主允许不得转载。 原理本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器。由于 webpack 不支持以.js意外的文件，loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。plugin用于扩展了 webpack 的功能，插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。 功能 依赖管理：让模块更容易的被复用，避免全局引入的冲突，避免重复导入或加载不需要的模块 合并代码：把各个分散的模块打包成一个文件，减少HTTP的请求数量 文件压缩：代码和图片压缩减少体积，字节数小的图片文件可被编译成base64直接插入文件中 各路插件：babel插件将ES6转译成ES5 构建的过程 解析配置参数：合并shell和webpack.config.js文件中的配置信息，输出最终的配置信息 注册配置插件：好让插件监听webpack生命周期的事件节点，做出对应的反应 解析entry入口：找出每个文件中所有的文件，从而递归下去 loader解析：在递归的每个文件中，找出对应的loader进行解析。递归结束后，得到最终的chunk chunk输出：输出chunk到文件系统","categories":[],"tags":[]},{"title":"利用百度地图API，不需要秘钥即可找出周边的标记点的经纬度","slug":"利用百度地图API，不需要秘钥即可找出周边的标记点的经纬度","date":"2017-11-01T07:55:43.000Z","updated":"2018-01-21T06:16:28.000Z","comments":true,"path":"2017/11/01/利用百度地图API，不需要秘钥即可找出周边的标记点的经纬度/","link":"","permalink":"http://yoursite.com/2017/11/01/利用百度地图API，不需要秘钥即可找出周边的标记点的经纬度/","excerpt":"","text":"版权声明：本文为博主原创文章，未经博主允许不得转载。 由于需要深圳某一点周边的学校，医院，消防的经纬度数据，有麻烦的办法，就是利用百度地图的拾取坐标系统去一个一个找出来，点击复制，过程是很繁琐的，而且也经常会忘记你点过哪里了。所以，去看了周边搜索的API，功夫不负有心人，可是在控制台打印出来想要的数据了 百度地图周边搜索APIdemo需要在这个demo上操作，不需要去申请秘钥，可是省了大半会儿的时间。打开页面是这样的： 把源代码编辑器的JavaScript代码替换成，如下： // 百度地图API功能 var map = new BMap.Map(&quot;allmap&quot;); // 创建Map实例 var mPoint = new BMap.Point(114.048117,22.526108); map.enableScrollWheelZoom(); map.centerAndZoom(mPoint,15); var circle = new BMap.Circle(mPoint,5000,{fillColor:&quot;blue&quot;, strokeWeight: 1 ,fillOpacity: 0.3, strokeOpacity: 0.3}); map.addOverlay(circle); var local = new BMap.LocalSearch(map, {renderOptions: {map: map},onSearchComplete: function(results){console.log(results)}}); local.searchNearby(&apos;学校&apos;,mPoint,5000); 然后点击右上角的运行按钮 就搜索出要的定位点了，可是我们要的是经纬度呀，别急，f12 打开控制台，就可以看到有json数据输出 在上面的代码中，学校是关键字mPoint是定位的中心点5000是搜索的范围可根据具体的要求进行更改 local.searchNearby(&apos;学校&apos;,mPoint,5000);","categories":[],"tags":[]},{"title":"字体图标库，解决使用icon图标的烦恼","slug":"字体图标库，解决icon图标烦恼","date":"2017-10-30T12:45:13.000Z","updated":"2018-03-11T03:23:48.000Z","comments":true,"path":"2017/10/30/字体图标库，解决icon图标烦恼/","link":"","permalink":"http://yoursite.com/2017/10/30/字体图标库，解决icon图标烦恼/","excerpt":"","text":"版权声明：本文为博主原创文章，未经博主允许不得转载。 css雪碧图以前最经常使用的小图标都会做css雪碧图，是一种CSS图像合并技术，该方法是将小图标和背景图像合并到一张图片上，然后利用css的背景定位来显示需要显示的图片部分。 他的优点是 减少加载网页图片时对服务器的请求次数 提高页面的加载速度 减少鼠标滑过的一些bug 但是他的缺点也是挺让人烦恼的 CSS雪碧的最大问题是内存使用 拼图维护比较麻烦 使CSS的编写变得困难 因为他的使用比较繁琐，注意的问题较多，字体图标只要一个简单的文件，就能实现图标的展示，而且控制图片就当文字来css编辑，图标的大小，粗细，颜色前端开发人员改起来就简单多了，所以css雪碧图慢慢的就被遗弃了。 font-awesome现在，字体图标使用简单而被广泛的使用。原理是很简单的，利用字体工具把我们平时 Web 上用的图形图标（icons）转换成 web fonts，就成了 icon fonts。因为字体是矢量化图形，它天生具有「分辨率无关」的特性，在任何分辨率和PPI下面，都可以做到完美缩放，不会像传统位图， 如：png，jpeg，放大后有锯齿或模糊现象。使用它可以轻松地解决雪碧图所遇到的问题，因为一旦将 icons 当作普通 text 来处理，自由改变字体大小，自由演变字体颜色，有了 CSS3 的支持，可以添加一些视觉效果如：阴影 ，透明度等，旋转几下是相当轻松的。 最具有代表性的应当属font-awesome莫属了，使用起来也是相当简单的。 引入文件 方法一：将以下代码粘贴到网页HTML代码的 部分. &lt;link href=&quot;//netdna.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css&quot; rel=&quot;stylesheet&quot;&gt; 方法二：下载 font-awsome 字体图标文件到本地，复制整个 font-awesome 文件夹到您的项目中。在HTML的 中引用font-awesome.min.css。 &lt;link rel=&quot;stylesheet&quot; href=&quot;/font-awesome/css/font-awesome.min.css&quot;&gt; html中使用字体图标 &lt;i class=&quot;fa fa-home&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; Iconfont使用字体库 随着字体图标的发展，前端的广泛使用，基本的font-awesome的字体图标数量已经满足不了需求。Iconfont.cn是由阿里巴巴UX部门推出的矢量图标管理网站，也是国内首家推广Webfont形式图标的平台。网站涵盖了1000多个常用 图标并还在持续更新中，Iconfont平台为用户提供在线图标搜索、图标分捡下载、在线储存、矢量格式转换、个人图标库管理及项目图标管理等基础功能。有了它，妈妈再也不用担心我找不到合适的图标了。 用法也是相当的简单： 进入官网 icon-font 点击搜索你需要的icon 点击加入购物车， 添加完成之后，最后点击右上角的购物车，添加至项目（或创建新的项目） 下载到你的本地 把下载的文件的icon-font.css文件copy到你的项目文件中，引用文件 &lt;link rel=&quot;stylesheet&quot; href=&quot;../css/iconfont.css&quot;&gt; 在html添加代码： &lt;i class=&quot;iconfont icon-home&quot;&gt;&lt;/i&gt; 添加svg文件生成字体 如果你想自定义生成自己想要的图标，那icon-font也可以帮助你实现 点击上传的图标，进入上传界面 选择已经做好的svg图片，保存提交，之后就回到字体使用的步骤了 github上的栗子https://github.com/YY56/icon-font","categories":[],"tags":[]},{"title":"max 上使用svn客户端","slug":"max-上使用svn","date":"2017-10-27T09:01:47.000Z","updated":"2017-10-27T09:23:21.000Z","comments":true,"path":"2017/10/27/max-上使用svn/","link":"","permalink":"http://yoursite.com/2017/10/27/max-上使用svn/","excerpt":"","text":"版权声明：本文为博主原创文章，未经博主允许不得转载。 mac上有自带的svn服务端和客户端的功能，所以我们不用借助第三方软件就可以使用svn来帮我们快速的实现版本的管理。 使用svn客户端1.创建一个新的文件夹用于存放 ，然后进入文件夹，检出工作副本， mkdir svnrtest cd svntest svn checkout https://地址 --username xxx --password xxx 也可以不提前输入用户i名和密码，直接回车，跟着控制台的提示输入。 2.增加文件或文件夹或增加所有 svn add css svn ass reset.css svn add * --force 3.提交文件或文件夹或提交所有 svn commit -m &apos;ps&apos; index.html svn commit -m &apos;ps&apos; html svn commit -m &apos;ps&apos; * 4.更新文件 svn update 5.删除文件 svn rremove reset.css","categories":[],"tags":[]},{"title":"学习MongoDB笔记","slug":"学习MongoDB笔记","date":"2017-10-07T08:51:47.000Z","updated":"2017-11-15T07:24:16.000Z","comments":true,"path":"2017/10/07/学习MongoDB笔记/","link":"","permalink":"http://yoursite.com/2017/10/07/学习MongoDB笔记/","excerpt":"","text":"版权声明：本文为博主原创文章，未经博主允许不得转载。 为什么要选择mongobgmongodb是开源的noSQL数据库(NoSQL = Not Only SQL )，也被叫做“芒果数据库”，免费，开源，良好的技术支持。github，淘宝，京东，360，百度都在使用。NoSQL的拥护者们提倡运用非关系型的数据存储，相对于铺天盖地的关系型数据库运用，这一概念无疑是一种全新的思维的注入。 1、基本的用法是存储JSON数据，这很适合JavaScript程序。其特性如下： 没有表结构的概念，每条记录可以有完全不同的结构 业务开发方便快捷 sql数据库需要事先定义表结构再使用 2、完全支持索引: 单键索引、多建索引 数组索引 地理位置索引 3、方便的冗余和扩展： 数据集保证数据安全 分片扩展数据规模 4、良好的支持： 完善的文档 齐全的驱动支持 搭建简单服务Mac OX上安装mongodb,mongodb的安装有好多种安装方法，有普通青年的HomeBrew方式，也有文艺青年的源码编译方式。我只想快速的装起来用一下，所以我选最简单的HomeBrew 更新Homebrew的package数据库，在Mac的终端中输入：时间有可能会比较长，没有信息提示，需要耐心等待 $ brew update 开始安装mongodb:然后继续等待mongodb下载完成。这个比较贴心了，有下载进度百分比。 $ brew install mongodb 修改环境变量： $ touch .base_profile $ open .base_profile 加入path，保存 export MONGO_PATH=/usr/local/mongodb export PATH=$PATH:$MONGO_PATH/bin 启动mongodb服务端： $ mongod --config /usr/local/etc/mongod.conf $ mongo （注：mongod.conf文件中bindIp: 127.0.0.1意思是本机访问，如果是外网访问需要重新设置）如果要修改数据库路径的话，终端输入 mongod –dbpath 路径 此时，可以通过http访问该数据库，mongodb使用了27017端口，因此在浏览器中打开http://localhost:27017/。出现如下提示即说明连接成功了 基本文档的增删改查 操作 说明 show dbs 查看目前有多少数据库 show tables 查看有多少表（集合） show collections 查看有多少表（集合） use imooc 切换imooc数据库，没有的话会自动创建 db.imooc_2.insert({x:1}) 在imooc_2表中插入一条数据x等于1(可以使用js语句循环插入数据) db.imooc_2.find() 查询imooc_2表中所有数据 db.imooc_2.find({x:1}) 查询相等于1 的数据 db.imooc_2.find().count() 计算imooc_2集合中有多少数据 db.imooc_2.find().skip(n) 查询的时候跳过n条数据 db.imooc_2.find().limit(n) 查询的时候限制n条数据 db.imooc_2.find().sort({x:1}) 按x排序 db.imooc_2.find({x:{$gt:100,$lte:120}}) 查找x大于100小于等于120 的数据 db.imooc_2.update({x:1},{x:999}) 把x为1 的数据更新为 999 db.imooc_2.update({z:1},{$set:{x:2}}) 把数据有z为1的数据的x更新为2（及一条数据中的部分更新） db.imooc_2.update({y:2},{y:999},true) 更新数据库中不存在的数据（及插入一条不存在的数据） db.imooc_2.update({c:1},{$set:{c:2}},false,true) 更新全部c为1的数据为2，false表示只更新存在的数据，true表示更新全部数据（数据库默认只更新第一条数据） db.imooc_2.remove({c:2}) 删除c为2的数据（删除是全部的） db.imooc_2.drop() 删除imooc_2表（集合） db.dropDatabase() 删除imooc_2数据库 $gt ——– greater than &gt;$gte ——— gt equal &gt;=$lt ——– less than &lt;$lte ——— lt equal &lt;=$ne ———– not equal !=$eq ——– equal = 各种类型的索引的创建与使用优点：加快索引相关查询缺点：增加磁盘消耗,降低写入性能 操作 说明 自动生成的唯一的 _id索引 db.tbname.ensureIndex({x:1/-1}) 单键索引(1/-1,表示排序） db.tbname.ensureIndex({x:1,y:-1}) 复合索引 db.tbname.ensureIndex({time: 1},{expireAfterSeconds:30}) 过期索引（登录用户的记录,必须是时间类型 new Date（），不能使用时间搓） db.page.ensureIndex({title:”text”}) 全文索引 db.page.find({$text:{$search: “aa”}}) 全文索引例子 db.page.find({$text:{$search: “aa -cc”}}) 全文索引例子 db.page.find({$text:{$search: “\\”aa\\” \\”bb\\””}}) 全文索引例子 db.page.find({$text:{$search: “aa”}},{score:{$meta:”textScore”}}).sort({score:{$meta:”textScore”}}) 全文索引例子 db.location.ensureIndex({w:’2d’}) 地理位置索引 db.location.find({w:{$near:[1,1]}}) 地理位置例子 db.location.find({w:{$near:[1,1],$maxDistance:10,$minDistance:1}}) 地理位置例子 db.location.find({w:{$geoWithin:{$box:[[0,0],[3,3]]}}}) 地理位置例子 db.location.find({w:{$geoWithin:{$center:[[1,1],2]}}}) 地理位置例子 db.location.find({w:{$geoWithin:{$polygon:[[0,0],[2,2],[6,1],[10,10]]}}}) 地理位置例子 db.runCommand({geoNear:”location”,near:[2,2],maxDistance:10,num:2}) 地理位置例子 db.tbname.dropIndex(‘name’) 删除索引 db.tbname.ensureIndex({x:1,y:1,z:1},{name:xyz_index}) 设置索引名字 db.tbname.ensureIndex({x:1},{unique:true}) 设置索引唯一性 db.tbname.ensureIndex({m :1},{sparse:true}) 设置索引洗属性（对文档中不存在的字段数据不启用索引；这个参数需要特别注意，如果设置为true的话，在索引字段中不会查询出不包含对应字段的文档.。默认值为 false.）","categories":[],"tags":[]},{"title":"JS实现 EasyUI-Tree 数据格式转换","slug":"JS实现-EasyUI-Tree-数据格式转换","date":"2017-09-11T07:49:29.000Z","updated":"2017-09-11T09:01:50.000Z","comments":true,"path":"2017/09/11/JS实现-EasyUI-Tree-数据格式转换/","link":"","permalink":"http://yoursite.com/2017/09/11/JS实现-EasyUI-Tree-数据格式转换/","excerpt":"","text":"版权声明：本文为博主原创文章，未经博主允许不得转载。 废话不多说，先上代码： loadFilter:function(content){ let bufferData = {};// 缓存数据 let node = null; let parentNode = null; for (let i = 0; i &lt; content.length; i++) { node = content[i];//当前节点 parentNode = bufferData[node.parentId];//父节点 if (parentNode == undefined) { // 如果在树结构数据中不存在父节点则创建一个 parentNode = bufferData[node.parentId] = {children: []}; } if (node.leaf == false) { if (bufferData[node.id] == undefined){ node.children = []; //如果自己的位置上没有代替者则增加一个未来装载子节点的容器 }else node.children = bufferData[node.id].children;//如果有代理者证明有子节点在自身之前被遍历，将代理者搜集的内容拷贝过来 bufferData[node.id] = node;//剔除代理者 } parentNode.children.push(node); } return [content[0]] }, 返回的数据需要有自身 id ,父节点 parentId 叶子节点的判断 leaf 原始数据： [ {&quot;id&quot;:1,&quot;parentId&quot;:-1,&quot;leaf&quot;:0,&quot;text&quot;:&quot;班级&quot;}, {&quot;id&quot;:2,&quot;parentId&quot;:1,&quot;leaf&quot;:0,&quot;text&quot;:&quot;班长&quot;}, {&quot;id&quot;:3,&quot;parentId&quot;:1,&quot;leaf&quot;:0,&quot;text&quot;:&quot;副班长&quot;}, {&quot;id&quot;:4,&quot;parentId&quot;:2,&quot;leaf&quot;:1,&quot;text&quot;:&quot;学生A&quot;}, {&quot;id&quot;:5,&quot;parentId&quot;:2,&quot;leaf&quot;:1,&quot;text&quot;:&quot;学生B&quot;}, {&quot;id&quot;:6,&quot;parentId&quot;:3,&quot;leaf&quot;:1,&quot;text&quot;:&quot;学生C&quot;} ] 转换后的数据： [ { &quot;id&quot;:1, &quot;parentId&quot;:-1, &quot;leaf&quot;:0, &quot;text&quot;:&quot;班级&quot;, &quot;children&quot;:[ { &quot;id&quot;:2, &quot;parentId&quot;: 1, &quot;leaf&quot;:0, &quot;text&quot;:&quot;班长&quot;, &quot;children&quot;:[ { &quot;id&quot;:4, &quot;parentId&quot;:2, &quot;leaf&quot;:1, &quot;text&quot;:&quot;学生A&quot; },{ &quot;id&quot;:5, &quot;parentId&quot;:2, &quot;leaf&quot;:1, &quot;text&quot;:&quot;学生B&quot; } ] }, { &quot;id&quot;:3, &quot;parentId&quot;:1, &quot;leaf&quot;:0, &quot;text&quot;:&quot;副班长&quot;, &quot;children&quot;:[ { &quot;id&quot;:6, &quot;parentId&quot;:3, &quot;leaf&quot;:1, &quot;text&quot;:&quot;学生C&quot; } ] } ] } ]","categories":[],"tags":[]},{"title":"Js 引擎的LHS、RHS查询","slug":"Js-引擎的LHS、RHS查询","date":"2017-08-30T03:47:48.000Z","updated":"2017-08-31T01:03:15.000Z","comments":true,"path":"2017/08/30/Js-引擎的LHS、RHS查询/","link":"","permalink":"http://yoursite.com/2017/08/30/Js-引擎的LHS、RHS查询/","excerpt":"","text":"版权声明：本文为博主原创文章，未经博主允许不得转载。 在写 js 代码的时，编译器在编译的时候生成了代码，引擎执行它时，会通过查找变量 a 来判断它是否已经声明过。查找的过程中需要通过作用域来协助，这时候引擎会为变量 a 进行 LHS 查询，另一种查询类型是 RHS 查询。及当变量出现在 “=” 的左侧的时进行 LHS 查询，出现在右侧时进行 RHS 查询。讲的更好理解一点，LHS 查询出来的是变量的地址，而 RHS 查询出来的是变量存储的值。 function foo(a){ console.log(a) } foo(2) 让我们把上面的代码处理成一段对话，来让我更加容易的去理解： 来自《你不知道的JavaScript》 引擎：我需要对foo进行RHS引用，你见过它吗？ 作用域：别说，我还真见过，编译器那小子刚刚才编译了他，它是一个函数，给你。 引擎：哥们太够意思了！好吧，我来执行一下foo。 引擎：作用域，还有个事儿，我需要对a进行LHS引用，这个你见过吗？ 作用域：这个也见过，编译器最近把它声明为foo的一个形式参数，拿去吧。 引擎：大恩不言谢啊，你总是那么棒，现在我要把2赋值给a。 引擎：哥们，不好意思，我又来了打扰你了。我要对console进行RHS引用，你见过它吗？ 作用域：咱俩谁跟谁啊，再说我就是干这个，这个我也有，console是个内置对象，给你。 引擎：么么哒。我得看看这里面是不是有log(···)，太好了，找到了，是个函数。 引擎：哥们，你能在帮我找找对a的RHS引用吗？虽然我记得它，但是我想再确认一下。 作用域：放心吧，这个变量没有动过，拿走，不谢。 引擎：真棒！我来把a的值，也就是2传递进log(..) ······","categories":[],"tags":[]},{"title":"Less 之快速入门","slug":"Less-之快速入门","date":"2017-08-20T03:50:50.000Z","updated":"2018-01-21T06:57:26.000Z","comments":true,"path":"2017/08/20/Less-之快速入门/","link":"","permalink":"http://yoursite.com/2017/08/20/Less-之快速入门/","excerpt":"","text":"版权声明：本文为博主原创文章，未经博主允许不得转载。 Less 是一种动态样式语言，它将CSS赋予了动态语言的特性。如：变量，继承，运算，函数。LESS 既可以在客户端上运行(支持IE 6+,Webkit,Firefox)，也可以借助Node.js或者Rhino在服务端运行。 Ps: Less需要编译，才能转成CSS文件，上一篇文章详细介绍了 我个人比较常用的快速的编译的方法，希望对小伙伴们有所帮助。 #注释Less // 注释（该注释不会被编译到CSS文件里面） /*注释（该注释会被编译到CSS文件里面）*/ Less 编译完成的CSS /*注释（该注释会被编译到CSS文件里面）*/ #变量Less // 变量的声明 @wine_red : #900; .box{ background-color: @wine_red; } Less 编译完成的CSS .box{ background-color: #900; } #混合Less // 变量的声明 @wine_red : #900; .box{ background-color: @wine_red; .box_1; .box_2(5px); .box_3(#09f); } // 混合 .box_1(){ width: 200px; height: 200px; } // 带参数的混合 .box_2(@radius) { border-radius: @radius; } // 带默认参数的混合 .box_3(@color, @border: 6px) { border: @border solid @color; } Less 编译完成的CSS .box{ background-color: #900; width: 200px; height: 200px; border-radius: 5px; border: 6px solid #09f; } #匹配模式Less .angle{ .triangle(top) } // 匹配模式 .triangle(@_, @w:10px, @c:#ccc) { width: 0; height: 0; overflow: hidden; } .triangle(top, @w:10px, @c:#ccc) { border-width: @w; border-style: dashed dashed solid dashed; border-color: transparent transparent @c transparent; } .triangle(right,@w:10px, @c:#ccc) { border-width: @w; border-style: dashed dashed dashed solid; border-color: transparent transparent transparent @c; } .triangle(bottom,@w:10px, @c:#ccc) { border-width: @w; border-style: solid dashed dashed dashed; border-color: @c transparent transparent transparent; } .triangle(left,@w:10px, @c:#ccc) { border-width: @w; border-style: dashed solid dashed dashed; border-color: transparent @c transparent transparent; } Less 编译完成的CSS .angle { width: 0; height: 0; overflow: hidden; border-width: 10px; border-style: dashed dashed solid dashed; border-color: transparent transparent #ccc transparent; } #运算Less .box{ .box_4() } // 运算 .box_4(){ width: 200px - 20; } Less 编译完成的CSS .box { width: 180px; } #嵌套Less // 嵌套 nav{ ul{ padding-left: 0; font-size: 0; li{ display: inline-block; width: 40px; height: 20px; background-color: #900; margin-left: 4px; &amp;.item{ background-color: #098; } &amp;:hover{ background-color: #222; } } } } Less 编译完成的CSS nav ul { padding-left: 0; font-size: 0; } nav ul li { display: inline-block; width: 40px; height: 20px; background-color: #900; margin-left: 4px; } nav ul li.item { background-color: #098; } nav ul li:hover { background-color: #222; }","categories":[],"tags":[]},{"title":"Less自动编译成css的简单快速的方法","slug":"Less自动编译成css的简单快速的方法","date":"2017-08-15T12:13:06.000Z","updated":"2018-01-21T06:58:23.000Z","comments":true,"path":"2017/08/15/Less自动编译成css的简单快速的方法/","link":"","permalink":"http://yoursite.com/2017/08/15/Less自动编译成css的简单快速的方法/","excerpt":"","text":"版权声明：本文为博主原创文章，未经博主允许不得转载。 我之前最先学习less的时候用的是koala进行编译，它既可以编译less也可以编译sass，使用起来也是比较方便的，但是需要下载工具，简单配置一下即可使用。这里我说的不是这个方法，感兴趣的可以去看看。还有一些其他的方法，比如用vue的开发，使用webpack配置。Less 还和流行的 Grunt 构建工具进行了集成，可以参考 grunt-contrib-less 插件。 现在我来说我最近比较经常用的方法： 使用sublime text的less2css插件 步骤： 需要安装node.js,这个到官网下载即可 需安装less，在命令行输入： npm install less -g sublime安装less2css，方法：ctrl+shift+p &gt; install Package &gt; 输入 less2css 按 Enter 配置less2css，方法：Preferences &gt; Package Settings &gt; Less2Css &gt; Settings-Default 5.执行编写好less文件后 按下ctrl+s 就会在当前目录下生成同名的css文件 但是之后的问题就来了，每次保存的时候都会弹出提示信息 解决方法：Preferences &gt; Package Settings &gt; Less2Css &gt; Settings-User 加入以下代码: { &quot;minify&quot;:false }","categories":[],"tags":[]},{"title":"vue之常用的插件安装","slug":"vue之常用的插件安装","date":"2017-08-14T11:35:10.000Z","updated":"2018-07-26T13:16:56.000Z","comments":true,"path":"2017/08/14/vue之常用的插件安装/","link":"","permalink":"http://yoursite.com/2017/08/14/vue之常用的插件安装/","excerpt":"","text":"版权声明：本文为博主原创文章，未经博主允许不得转载。 创建Vue项目模版 创建一个基于 webpack 模板的新项目 $ vue init webpack my-project 进入文件夹 $ cd my-project 安装依赖，走你 $ npm install 启动项目 $ npm run dev 安装项目中所需要的插件 安装less及less-loader 解析css $ npm install less less-loader --save 在.vue文件中使用 &lt;style lang=&quot;less&quot;&gt;&lt;/style&gt; 安装vue-lazyload 图片懒加载 $ npm install vue-lazyload --save 安装vant ui插件api: https://youzan.github.io/vant/#/zh-CN/quickstart $ npm install vant -S 安装为webApp 提供转场特效的的vueg开源插件使用： https://blog.csdn.net/qq_36648555/article/details/78505965 $ npm i vueg -G 安装 animate 动画插件库使用： https://blog.csdn.net/qq_25804071/article/details/70911421demo： http://about.asika.tw/vue2-animate/ $ npm install --save vue2-animate","categories":[],"tags":[]},{"title":"如何使用命令行快速打开sublime编辑器","slug":"如何使用命令行快速打开sublime编辑器","date":"2017-02-01T01:59:38.000Z","updated":"2018-02-07T07:37:48.000Z","comments":true,"path":"2017/02/01/如何使用命令行快速打开sublime编辑器/","link":"","permalink":"http://yoursite.com/2017/02/01/如何使用命令行快速打开sublime编辑器/","excerpt":"","text":"版权声明：本文为博主原创文章，未经博主允许不得转载。 建立软链：（如果是 sublime Text 2） sudo ln -s /Applications/Sublime\\ Text\\ 2.app/Contents/SharedSupport/bin/subl /usr/local/bin/sublime 建立软链：（如果是 sublime Text） sudo ln -s /Applications/Sublime\\ Text.app/Contents/SharedSupport/bin/subl /usr/local/bin/sublime 然后就可以用sublime命令打开文件了 sublime hello.txt sublime –help列出subl的常用命令集 –project : Load the given project –command : Run the given command -n or –new-window: Open a new window -a or –add: Add folders to the current window -w or –wait: Wait for the files to be closed before returning -b or –background: Don’t activate the application -s or –stay: Keep the application activated after closing the file -h or –help: Show help (this message) and exit -v or –version: Show version and exit sublime 文件名使用sublime打开文件 sublime -n 文件名以新窗口打开文件 sublime -a 文件夹名将当前文件夹添加到sublime当前窗口中 sublime -n 文件夹名将当前文件夹添加到sublime的新窗口中","categories":[],"tags":[]},{"title":"上传到github仓库，并在线浏览网页","slug":"putingithub","date":"2017-01-04T08:36:27.000Z","updated":"2017-11-03T03:28:09.000Z","comments":true,"path":"2017/01/04/putingithub/","link":"","permalink":"http://yoursite.com/2017/01/04/putingithub/","excerpt":"","text":"版权声明：本文为博主原创文章，未经博主允许不得转载。 第一步：首先准备好你需要上传的文件夹，里面有你写好的html、js和css文件等在账号下创建一个仓库，名字为into来到你的目录下 此时已经进入文件夹，输入 git add index.html git add style.css git add render.js git commit -m &quot;first commit&quot; git remote add origin git@github.com:yourname/intro. git git push -u origin master 之后显示 Counting objects: 4, done. Delta compression using up to 4 threads. Compressing objects: 100% (4/4), done. Writing objects: 100% (4/4), 30.90 KiB | 0 bytes/s, done. Total 4 (delta 0), reused 0 (delta 0) * [new branch] master -&gt; master Branch master set up to track remote branch master from origin. 就可以了，返回到你的仓库里，就可以看到了 第二步：在个人的github上找到setting设置按钮 第三步：最后复制地址访问就ok了","categories":[],"tags":[]},{"title":"ajax","slug":"ajax","date":"2016-10-19T12:18:54.000Z","updated":"2017-09-05T01:18:39.000Z","comments":true,"path":"2016/10/19/ajax/","link":"","permalink":"http://yoursite.com/2016/10/19/ajax/","excerpt":"","text":"版权声明：本文为博主原创文章，未经博主允许不得转载。 在学习之前，您需要对下面的知识有基本的了解：HTML / XHTMLCSSJavaScript / DOM 什么是 AJAX ？AJAX = 异步 JavaScript 和 XML。AJAX 是一种用于创建快速动态网页的技术。通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用 AJAX）如果需要更新内容，必需重载整个网页面。有很多使用 AJAX 的应用程序案例：新浪微博、Google 地图、开心网等等。 创建 XMLHttpRequest 对象XMLHttpRequest 用于在后台与服务器交换数据。创建 XMLHttpRequest 对象的语法：variable=new XMLHttpRequest();老版本的 Internet Explorer （IE5 和 IE6）使用 ActiveX 对象：variable=new ActiveXObject(“Microsoft.XMLHTTP”); var xmlhttp; if (window.XMLHttpRequest){// code for IE7+, Firefox, Chrome, Opera, Safari xmlhttp=new XMLHttpRequest(); }else{// code for IE6, IE5 xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); } 向服务器发送请求如需将请求发送到服务器，我们使用 XMLHttpRequest 对象的 open() 和 send() 方法：xmlhttp.open(“GET”,”test1.txt”,true);xmlhttp.send();方法 描述open(method,url,async)规定请求的类型、URL 以及是否异步处理请求。method：请求的类型；GET 或 POSTurl：文件在服务器上的位置async：true（异步）或 false（同步）send(string)将请求发送到服务器。string：仅用于 POST 请求 GET 还是 POST？与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。然而，在以下情况中，请使用 POST 请求：无法使用缓存文件（更新服务器上的文件或数据库）向服务器发送大量数据（POST 没有数据量限制）发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠 为了缓存情况，请向 URL 添加一个唯一的 IDxmlhttp.open(“GET”,”demo_get.asp?t=” + Math.random(),true);xmlhttp.send();如果需要像 HTML 表单那样 POST 数据，请使用 setRequestHeader() 来添加 HTTP 头。然后在 send() 方法中规定您希望发送的数据：xmlhttp.open(“POST”,”ajax_test.asp”,true);xmlhttp.setRequestHeader(“Content-type”,”application/x-www-form-urlencoded”);xmlhttp.send(“fname=Bill&amp;lname=Gates”); onreadystatechange 事件当请求被发送到服务器时，我们需要执行一些基于响应的任务。每当 readyState 改变时，就会触发 onreadystatechange 事件。readyState 属性存有 XMLHttpRequest 的状态信息。onreadystatechange 存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。readyState存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。0: 请求未初始化1: 服务器连接已建立2: 请求已接收3: 请求处理中4: 请求已完成，且响应已就绪status200: “OK”404: 未找到页面 xmlhttp.onreadystatechange=function(){ if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200){ document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText; } } 完整的实例var xmlhttp; function loadXMLDoc(url,cfunc){ if (window.XMLHttpRequest){// code for IE7+, Firefox, Chrome, Opera, Safari xmlhttp=new XMLHttpRequest(); }else{// code for IE6, IE5 xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); } xmlhttp.onreadystatechange=cfunc; xmlhttp.open(&quot;GET&quot;,url,true); xmlhttp.send(); } function myFunction(){ loadXMLDoc(&quot;/ajax/test1.txt&quot;,function(){ if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200){ document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText; } }); }","categories":[],"tags":[]},{"title":"React入门","slug":"React入门","date":"2016-09-10T13:27:12.000Z","updated":"2017-08-30T07:33:56.000Z","comments":true,"path":"2016/09/10/React入门/","link":"","permalink":"http://yoursite.com/2016/09/10/React入门/","excerpt":"","text":"前置知识1.JS，CSS基础2.Sass，Compass3.Yeoman，Grunt，Webpack4.CommonJS，NodeJS5.Git，Github JSXJSX字面上的意思就是javascript和xml，是facebook为react 框架开发的一套语法糖。｛解析js的表达式｝需要解析库解析，最终被解析成JS。type为text/jsx。 html只有个根元素，div id=”container”。 css声明类名改为className，内联样式style＝｛｛color：‘red’｝｝。","categories":[],"tags":[]},{"title":"HEXO+github,搭建属于自己的博客","slug":"HEXO-github-搭建属于自己的博客","date":"2016-09-06T13:34:18.000Z","updated":"2017-09-05T01:01:42.000Z","comments":true,"path":"2016/09/06/HEXO-github-搭建属于自己的博客/","link":"","permalink":"http://yoursite.com/2016/09/06/HEXO-github-搭建属于自己的博客/","excerpt":"","text":"hexo是一款基于Node.js的静态博客框架,hexo github链接,这篇教程是针对与Mac的.之前是想着写博客，一方面是给自己做笔记，可以提升自己的写作、总结能力，一个技术点我们会使用，并不难，但是要做到让让别人也能听懂我们讲得，还是需要一定的技巧和经验的。很多类似于CSDN、博客园也都可以写文章，但是页面的样式我，不是太喜欢，简书还算好点得。最近看到一些大神们的博客,貌似都是用hexo写得,我也依葫芦画瓢的搭建了一个。不罗嗦了，直接上搭建步骤。 配置环境安装Node（必须）作用：用来生成静态页面的到Node.js官网下载相应平台的最新版本，一路安装即可。 安装Git（必须）作用：把本地的hexo内容提交到github上去.安装Xcode就自带有Git，我就不多说了。 申请GitHub（必须）作用：是用来做博客的远程创库、域名、服务器之类的，怎么与本地hexo建立连接等下讲。github账号我也不再啰嗦了,没有的话直接申请就行了，跟一般的注册账号差不多，SSH Keys，看你自己了，可以不配制，不配置的话以后每次对自己的博客有改动提交的时候就要手动输入账号密码，配置了就不需要了，怎么配置我就不多说了，网上有很多教程。 正式安装HexoNode和Git都安装好后,首先创建一个文件夹,如blog,用户存放hexo的配置文件,然后进入blog里安装Hexo。执行如下命令安装Hexo：进入blog文件夹内 npm install hexo-cli -g npm install hexo-deployer-git --save hexo g hexo d hexo init hexo g hexo s 然后用浏览器访问http://localhost:4000/，此时，你应该看到了一个漂亮的博客了，当然这个博客只是在本地的，别人是看不到的，hexo3.0使用的默认主题是landscape。轻轻松松就看到了一点成果，是不是很激动，这就是hexo的强大之处，这个本地预览的功能，我真是爱不释手 配置Github建立Repository建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】，固定写法 然后建立关联，blog是我之前建的东西也全在这里面，有： _config.yml node_modules public source db.json package.json scaffolds themes 现在我们需要_config.yml文件，来建立关联，进入blog下的_config.yml文件，打开文件，deploy: type: git repo: https://github.com/your_user_name/your_user_name.github.io.git branch: master 然后执行命令： npm install hexo-deployer-git --save 然后，执行配置命令： hexo deploy 然后再浏览器中输入http://your_user_name.github.io/就行了.","categories":[],"tags":[]}]}