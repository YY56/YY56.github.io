{"meta":{"title":"mover's blog","subtitle":null,"description":null,"author":"liu yahui","url":"http://yoursite.com"},"pages":[{"title":"前端面试题","date":"2016-09-08T01:56:00.000Z","updated":"2017-05-14T12:51:25.000Z","comments":true,"path":"前端面试题.html","permalink":"http://yoursite.com/前端面试题.html","excerpt":"","text":"HTML+CSS 1.Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?&lt;!DOCTYPE&gt; 声明位于文档中的最前面，处于标签之前。告知浏览器以何种模式来渲染文档。严格模式的排版和 JS 运作模式是 以该浏览器支持的最高标准运行。在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。 2.HTML与XHTML——二者有什么区别所有的标记都必须要有一个相应的结束标记所有标签的元素和属性的名字都必须使用小写所有的XML标记都必须合理嵌套所有的属性必须用引号””括起来把所有&lt;和&amp;特殊符号用编码表示给所有属性赋一个值不要在注释内容中使“–”图片必须有说明文字（标签闭合，标签小写，合理的嵌套） 3.什么是语义化的HTML直观的认识标签，去掉或者丢失样式的时候能够让页面呈现出清晰的结构有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。 4.对WEB标准以及W3C的理解与认识标签闭合、标签小写、不乱嵌套、提高搜索机器人搜索几率、使用外 链css和js脚本、结构行为表现的分离、文件下载与页面速度更快、内容能被更多的用户所访问、内容能被更广泛的设备所访问、更少的代码和组件，容易维 护、改版方便，不需要变动页面内容、提供打印版本而不需要复制内容、提高网站易用性； 5.行内元素有哪些?块级元素有哪些?CSS的盒模型?行内元素：a,i,span,input,select块级元素：p,div,ui,li,h1~h4,form盒模型：内容,padding,border,margin 6.CSS引入的方式有哪些? link和@import的区别是?内联 内嵌 外链 导入link属于xhtml标签，而@import是css提供的在页面加载时link会同时被加载，而@import需要页面被加载完成后才加载@import只有在ie5 以上才被识别，而link无兼容性问题 7.CSS选择符有哪些?哪些属性可以继承?优先级算法如何计算?内联和important哪个优先级高?id选择符 类选择符 标签选择符id&gt;class&gt;标签选择符import优先级高 8.前端页面有哪三层构成，分别是什么?作用是什么?结构层 html表现层 css行为层 js 9.css的基本语句构成是?选择器{ 属性1：值1； 属性2：值2； ···} 10.你做的页面在哪些流览器测试过?这些浏览器的内核分别是什么ie(trident)火狐(Gecko)谷歌(webkit)opear(Presto) 11.标签上title与alt属性的区别是什么?title:为该属性是提供信息alt:图片为加载失败时的文字信息 12.描述css reset的作用和用途reset 重置浏览器默认的css的属性，由于浏览器的不同，会有不同是css初始值样式，重置样式，统一样式 13.解释css sprites，如何使用。由零散的图片合并成一张大图，减少服务器对图片的请求数量 14.浏览器标准模式和怪异模式之间的区别是什么?盒模型 渲染模式不同可以用 window.top.document.compatMode查看是什么模式 15.你如何对网站的文件和资源进行优化?期待的解决方案包括：合并文件压缩文件使用缓存使用CDN托管 16.简述一下src与href的区别href指向网络资源的位置，用于建立超链接src指向外部资源，请求时下载并嵌入标签内进行应用，例如js脚本，img 17.什么是CSS Hack?针对于不同的浏览器用同的css，就是css hackie浏览器一般分为三种css hack：条件hack 属性hack 选择器hack 18.简述同步和异步的区别同步为阻塞模式，异步为非阻塞模式同步：一个进程在执行某个请求，这个请求要一段时间才能返回信息，此时需要等待直到有信息的返回，该进程才执行下去异步：是指进程不需要等待，可以一直执行下去，等到有信息返回的时候进程会进行处理，这样可以提高执行效率 19.px和em的区别px和em都是长度单位。px是固定的值em是不固定的，继承父元素的字体大小，浏览器默认字体大小是16px 20.什么叫优雅降级和渐进增强优雅降级：一开始就构建完整的功能，然后再进行低版本的兼容渐进增强：针对低版本浏览器进行网页的构建，保证最低版本的功能，然后进行高版本浏览器效果，交互等改进和新功能的追加，达到最佳的用户体验。 20.HTML5 为什么只需要写 !DOCTYPE HTML？HTML5不是基于SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为，而HTML4.01是基于SGML所以需要引用DTD，才能告知浏览器文档所使用的文档类型。 21.请描述一下 cookies，sessionStorage 和 localStorage 的区别？不同:cookie在浏览器和服务器之前来回传递，而sessionStorage和locationStorage不会sessionStorage和locationStorage有独立的存储空间且存储空间更大，有丰富易用的接口。 大小不同:cookie 4K Storage 5M 有效期不同:cookie过期之前有效sessionStorage仅在浏览器关闭前有效locationStorage始终是有效的 作用域不同:sessionStorage在不同浏览器窗口不共享，即使是同一个页面cookie:同源共享locationStorage:同源共享 22.如何实现浏览器内多个标签页之间的通信?使用cookie和locationStorage等本地存储方式 23.CSS隐藏元素的几种方法（至少说出三种）opacity:占用原本的位置，影响用户的交互visibility:和opacity不同的是不影响用户的交互display:设置none值，效果是不占据位置，子昂是完全不存在一样。 24.CSS清除浮动的几种方法（至少两种）给父元素是设置height给父元素添加after伪类给父元素设置overflow：hidden给父元素设置overflow：auto尾部添加空标签div，并设置clear：both 25.html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？1.拖拽释放(Drag and drop) API2.语义化更好的内容标签（header,nav,footer,aside,article,section）3.音频、视频API(audio,video)4.画布(Canvas) API5.地理(Geolocation) API6.本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失； 26.CSS3有哪些新特性border-radius 圆角box-shadow 阴影gradient 渐变transform 旋转等 JS 1.javascript的typeof返回哪些数据类型number obj function boolean underfind 2.例举3种强制类型转换和2种隐式类型转换?强制转换:parseInt parseFloat number隐式转换:- == 3.split() join() 的区别split()是把字符串切割为数组join()是把数组拼接成字符串 4.数组方法pop() push() unshift() shift()pop()从数组尾数删除push()从数组尾部增加unshift()从数组的头部增加shift()从数组的尾部删除 5.IE和标准下有哪些兼容性的写法var ev = ev || window.eventvar target = ev.srcElement || ev.target 6.ajax请求的时候get 和post方式的区别get:将请求的参数加在url尾部，传送体积小，安全性低，通常用于数据的获取post:将请求包含在请求头里，传送的体积较大，由于参数没有暴露在url上，安全性较高，通常用于修改数据 7.call和apply的区别obj.call(this,obj1,obg2,···)obj.apply(this,arguments) 8.ajax请求时，如何解析json数据parse eval 但是对于parse的安全性更高 8.事件委托是什么利用冒泡原理，让自己的触发事件由父元代替执行 9.闭包是什么，有什么特性，对页面有什么影响闭包是可以读取其他函数内部变量的函数 10.如何阻止事件冒泡和默认事件function stopBubble(e){ if(e&amp;&amp;e.stopPropagation){ e.stopPropagation(); }else{ window.event.cancelBubble = true } } function stopDefault(e){ if(e&amp;&amp;e.stopDefault){ e.stopDefault() }else{ window.event.returnValue = false }} 11.添加 删除 替换 插入到某个接点的方法obj.appendChild()obj.removeChild()obj.repalceChild()obj.inserBefore() 12.解释jsonp的原理，以及为什么不是真正的ajax动态创建script标签，毁掉函数Ajax是无需刷新请求数据 13.javascript的本地对象，内置对象和宿主对象本地对象:array obj regexp等可以new的实例化对象内置对象:gload Math 等不可实例化的对象宿主对象:浏览器自带的 window document 等对象 14.document load 和document ready的区别load是结构样式加载完成后再执行jsready不是原生，JQ中有$().ready(function) 15.”==”和“===”的不同前者会自动转换，后者不会 16.javascript的同源策略一段脚本只能读取来自同一源的窗口和文档的属性，这里的同一源指的是主机名，协议和端口的组合 17.怎样创建和查找节点？创建节点createElement()createTextNode()查找节点getElementByTagName()getElementByName()getElementById() 18.如何消除一个数组里面重复的元素？var arr1 = [1,2,3,3,4,4,4,5,5,6]var arr2 = []for(var i = 0 ; i &lt; arr1.length ; i ++){ if(arr2.indexOf(arr1[i]) &lt; 0 ){ arr2.push(arr1[i]) }}document.write(arr2) 19.了解Node么？Node的使用场景都有哪些？高并发 聊天 实时消息推送 20.对于前端自动化构建工具有了解吗？简单介绍一下gulp grunt 21.this对象的理解this总是指向函数的直接调用者如果有关键字new，那就是new出来的那个对象在事件中，this指向触发该事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window 22.null和undefined的区别？null表示为一个“无”的对象，用数值表示为0作为函数的参数，表示该参数不是对象作为对象的原型链的终点 underfind表示一个“无”的原始值，用数字表示为NaN表示变量声明了，但是没有赋值调用函数式，提供的参数没有提供 23.JSON 的了解json是一种轻量级的数据格式，数据格式简单，易于读写，占用宽带小格式：{“age”：“12”，“name”：“lili”} HTTP 一次完整的HTTP事务是怎样的一个过程？域名解析发起TCP3次握手建立TCP连接后，发起http请求服务端响应请求，浏览器得到html代码浏览器解析html代码，并获取html代码中的资源在浏览器中对页面进行渲染 HTTP的状态码有哪些？100-199:指定客户端相应的操作200-299:请求成功300-399:重定向400-499:客户端错误500-599:服务端错误"},{"title":"前端兼容性问题与解决","date":"2016-10-06T01:05:55.000Z","updated":"2017-05-19T02:19:17.000Z","comments":true,"path":"前端兼容性问题与解决.html","permalink":"http://yoursite.com/前端兼容性问题与解决.html","excerpt":"","text":"css 1.ie浮动产生的双倍距离 给浮动的元素设置 display：inline-block 4.浏览器的默认的css各有不同，解决办法 设置css的初始样式reset，统一规定 3.背景透明问题 ie:filter:alpha(opacity=0.2)FF: opacity:0.6; 4.min-height最小高度的实现（兼容IE6、IE7、FF） height:auto;min-height:100px; 5.Box阴影(CSS3) .box { box-shadow: 5px 5px 5px #666; -moz-box-shadow: 5px 5px 5px #666; -webkit-box-shadow: 5px 5px 5px #666; } 6.文字与表单对齐方法？ vertical-align:middle 7.文字与图片垂直居中对齐方法？ 图片内嵌在文字里面，给文字设置 vertical-align:middle 8.图片的3像素距离 display：inline-blockjs1.event.x与event.y问题问题说明：IE下，even对象有x、y属性，但是没有pageX、pageY属性；Firefox下，even对象有pageX、pageY属性，但是没有x、y属性。解决方法：var myX = event.x ? event.x : event.pageX; var myY = event.y ? event.y:event.pageY; 2.event.srcElement问题 问题说明：IE下，even对象有srcElement属性，但是没有target属性；Firefox下，even对象有target属性，但是没有srcElement属性。解决方法：使用srcObj = event.srcElement ? event.srcElement : event.target; 3.window.location.href问题 问题说明：IE或者Firefox2.0.x下，可以使用window.location或window.location.href；Firefox1.5.x下，只能使用window.location。解决方法：使用 window.location 来代替 window.location.href。当然也可以考虑使用 location.replace()方法。 4.访问的父元素的区别 问题说明：在IE下，使用 obj.parentElement 或 obj.parentNode 访问obj的父结点；在firefox下，使用 obj.parentNode 访问obj的父结点。解决方法：因为firefox与IE都支持DOM，因此统一使用obj.parentNode 来访问obj的父结点。 5.innerText的问题. 问题说明：innerText在IE中能正常工作，但是innerText在FireFox中却不行。解决方法：在非IE浏览器中使用textContent代替innerText。示例：if(navigator.appName.indexOf(“Explorer”) &gt;-1){document.getElementById(‘element’).innerText = “my text”;} else{document.getElementById(‘element’).textContent = “;my text”;}[注] innerHTML 同时被ie、firefox等浏览器支持，其他的，如outerHTML等只被ie支持，最好不用。"}],"posts":[{"title":"字体图标库，解决你的icon图标烦恼","slug":"字体图标库，解决icon图标烦恼","date":"2017-10-31T12:45:13.000Z","updated":"2017-11-03T03:30:45.000Z","comments":true,"path":"2017/10/31/字体图标库，解决icon图标烦恼/","link":"","permalink":"http://yoursite.com/2017/10/31/字体图标库，解决icon图标烦恼/","excerpt":"","text":"版权声明：本文为博主原创文章，未经博主允许不得转载。 css雪碧图以前最经常使用的小图标都会做css雪碧图，是一种CSS图像合并技术，该方法是将小图标和背景图像合并到一张图片上，然后利用css的背景定位来显示需要显示的图片部分。 他的优点是 减少加载网页图片时对服务器的请求次数 提高页面的加载速度 减少鼠标滑过的一些bug 但是他的缺点也是挺让人烦恼的 CSS雪碧的最大问题是内存使用 拼图维护比较麻烦 使CSS的编写变得困难 因为他的使用比较繁琐，注意的问题较多，字体图标只要一个简单的文件，就能实现图标的展示，而且控制图片就当文字来css编辑，图标的大小，粗细，颜色前端开发人员改起来就简单多了，所以css雪碧图慢慢的就被遗弃了。 font-awesome现在，字体图标使用简单而被广泛的使用。原理是很简单的，利用字体工具把我们平时 Web 上用的图形图标（icons）转换成 web fonts，就成了 icon fonts。因为字体是矢量化图形，它天生具有「分辨率无关」的特性，在任何分辨率和PPI下面，都可以做到完美缩放，不会像传统位图， 如：png，jpeg，放大后有锯齿或模糊现象。使用它可以轻松地解决雪碧图所遇到的问题，因为一旦将 icons 当作普通 text 来处理，自由改变字体大小，自由演变字体颜色，有了 CSS3 的支持，可以添加一些视觉效果如：阴影 ，透明度等，旋转几下是相当轻松的。 最具有代表性的应当属font-awesome莫属了，使用起来也是相当简单的。 引入文件 方法一：将以下代码粘贴到网页HTML代码的 部分. &lt;link href=&quot;//netdna.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css&quot; rel=&quot;stylesheet&quot;&gt; 方法二：下载 font-awsome 字体图标文件到本地，复制整个 font-awesome 文件夹到您的项目中。在HTML的 中引用font-awesome.min.css。 &lt;link rel=&quot;stylesheet&quot; href=&quot;/font-awesome/css/font-awesome.min.css&quot;&gt; html中使用字体图标 &lt;i class=&quot;fa fa-home&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; Iconfont使用字体库 随着字体图标的发展，前端的广泛使用，基本的font-awesome的字体图标数量已经满足不了需求。Iconfont.cn是由阿里巴巴UX部门推出的矢量图标管理网站，也是国内首家推广Webfont形式图标的平台。网站涵盖了1000多个常用 图标并还在持续更新中，Iconfont平台为用户提供在线图标搜索、图标分捡下载、在线储存、矢量格式转换、个人图标库管理及项目图标管理等基础功能。有了它，妈妈再也不用担心我找不到合适的图标了。 用法也是相当的简单： 进入官网 icon-font 点击搜索你需要的icon 点击加入购物车， 添加完成之后，最后点击右上角的购物车，添加至项目（或创建新的项目） 下载到你的本地 把下载的文件的icon-font.css文件copy到你的项目文件中，引用文件 &lt;link rel=&quot;stylesheet&quot; href=&quot;../css/iconfont.css&quot;&gt; 在html添加代码： &lt;i class=&quot;iconfont icon-home&quot;&gt;&lt;/i&gt; 添加svg文件生成字体 如果你想自定义生成自己想要的图标，那icon-font也可以帮助你实现 点击上传的图标，进入上传界面 选择已经做好的svg图片，保存提交，之后就回到字体使用的步骤了 github上的栗子https://github.com/YY56/icon-font","categories":[],"tags":[]},{"title":"max 上使用svn客户端","slug":"max-上使用svn","date":"2017-10-27T09:01:47.000Z","updated":"2017-10-27T09:23:21.000Z","comments":true,"path":"2017/10/27/max-上使用svn/","link":"","permalink":"http://yoursite.com/2017/10/27/max-上使用svn/","excerpt":"","text":"版权声明：本文为博主原创文章，未经博主允许不得转载。 mac上有自带的svn服务端和客户端的功能，所以我们不用借助第三方软件就可以使用svn来帮我们快速的实现版本的管理。 使用svn客户端1.创建一个新的文件夹用于存放 ，然后进入文件夹，检出工作副本， mkdir svnrtest cd svntest svn checkout https://地址 --username xxx --password xxx 也可以不提前输入用户i名和密码，直接回车，跟着控制台的提示输入。 2.增加文件或文件夹或增加所有 svn add css svn ass reset.css svn add * --force 3.提交文件或文件夹或提交所有 svn commit -m &apos;ps&apos; index.html svn commit -m &apos;ps&apos; html svn commit -m &apos;ps&apos; * 4.更新文件 svn update 5.删除文件 svn rremove reset.css","categories":[],"tags":[]},{"title":"JS实现 EasyUI-Tree 数据格式转换","slug":"JS实现-EasyUI-Tree-数据格式转换","date":"2017-09-11T07:49:29.000Z","updated":"2017-09-11T09:01:50.000Z","comments":true,"path":"2017/09/11/JS实现-EasyUI-Tree-数据格式转换/","link":"","permalink":"http://yoursite.com/2017/09/11/JS实现-EasyUI-Tree-数据格式转换/","excerpt":"","text":"版权声明：本文为博主原创文章，未经博主允许不得转载。 废话不多说，先上代码： loadFilter:function(content){ let bufferData = {};// 缓存数据 let node = null; let parentNode = null; for (let i = 0; i &lt; content.length; i++) { node = content[i];//当前节点 parentNode = bufferData[node.parentId];//父节点 if (parentNode == undefined) { // 如果在树结构数据中不存在父节点则创建一个 parentNode = bufferData[node.parentId] = {children: []}; } if (node.leaf == false) { if (bufferData[node.id] == undefined){ node.children = []; //如果自己的位置上没有代替者则增加一个未来装载子节点的容器 }else node.children = bufferData[node.id].children;//如果有代理者证明有子节点在自身之前被遍历，将代理者搜集的内容拷贝过来 bufferData[node.id] = node;//剔除代理者 } parentNode.children.push(node); } return [content[0]] }, 返回的数据需要有自身 id ,父节点 parentId 叶子节点的判断 leaf 原始数据： [ {&quot;id&quot;:1,&quot;parentId&quot;:-1,&quot;leaf&quot;:0,&quot;text&quot;:&quot;班级&quot;}, {&quot;id&quot;:2,&quot;parentId&quot;:1,&quot;leaf&quot;:0,&quot;text&quot;:&quot;班长&quot;}, {&quot;id&quot;:3,&quot;parentId&quot;:1,&quot;leaf&quot;:0,&quot;text&quot;:&quot;副班长&quot;}, {&quot;id&quot;:4,&quot;parentId&quot;:2,&quot;leaf&quot;:1,&quot;text&quot;:&quot;学生A&quot;}, {&quot;id&quot;:5,&quot;parentId&quot;:2,&quot;leaf&quot;:1,&quot;text&quot;:&quot;学生B&quot;}, {&quot;id&quot;:6,&quot;parentId&quot;:3,&quot;leaf&quot;:1,&quot;text&quot;:&quot;学生C&quot;} ] 转换后的数据： [ { &quot;id&quot;:1, &quot;parentId&quot;:-1, &quot;leaf&quot;:0, &quot;text&quot;:&quot;班级&quot;, &quot;children&quot;:[ { &quot;id&quot;:2, &quot;parentId&quot;: 1, &quot;leaf&quot;:0, &quot;text&quot;:&quot;班长&quot;, &quot;children&quot;:[ { &quot;id&quot;:4, &quot;parentId&quot;:2, &quot;leaf&quot;:1, &quot;text&quot;:&quot;学生A&quot; },{ &quot;id&quot;:5, &quot;parentId&quot;:2, &quot;leaf&quot;:1, &quot;text&quot;:&quot;学生B&quot; } ] }, { &quot;id&quot;:3, &quot;parentId&quot;:1, &quot;leaf&quot;:0, &quot;text&quot;:&quot;副班长&quot;, &quot;children&quot;:[ { &quot;id&quot;:6, &quot;parentId&quot;:3, &quot;leaf&quot;:1, &quot;text&quot;:&quot;学生C&quot; } ] } ] } ]","categories":[],"tags":[]},{"title":"Js 引擎的LHS、RHS查询","slug":"Js-引擎的LHS、RHS查询","date":"2017-08-30T03:47:48.000Z","updated":"2017-08-31T01:03:15.000Z","comments":true,"path":"2017/08/30/Js-引擎的LHS、RHS查询/","link":"","permalink":"http://yoursite.com/2017/08/30/Js-引擎的LHS、RHS查询/","excerpt":"","text":"版权声明：本文为博主原创文章，未经博主允许不得转载。 在写 js 代码的时，编译器在编译的时候生成了代码，引擎执行它时，会通过查找变量 a 来判断它是否已经声明过。查找的过程中需要通过作用域来协助，这时候引擎会为变量 a 进行 LHS 查询，另一种查询类型是 RHS 查询。及当变量出现在 “=” 的左侧的时进行 LHS 查询，出现在右侧时进行 RHS 查询。讲的更好理解一点，LHS 查询出来的是变量的地址，而 RHS 查询出来的是变量存储的值。 function foo(a){ console.log(a) } foo(2) 让我们把上面的代码处理成一段对话，来让我更加容易的去理解： 来自《你不知道的JavaScript》 引擎：我需要对foo进行RHS引用，你见过它吗？ 作用域：别说，我还真见过，编译器那小子刚刚才编译了他，它是一个函数，给你。 引擎：哥们太够意思了！好吧，我来执行一下foo。 引擎：作用域，还有个事儿，我需要对a进行LHS引用，这个你见过吗？ 作用域：这个也见过，编译器最近把它声明为foo的一个形式参数，拿去吧。 引擎：大恩不言谢啊，你总是那么棒，现在我要把2赋值给a。 引擎：哥们，不好意思，我又来了打扰你了。我要对console进行RHS引用，你见过它吗？ 作用域：咱俩谁跟谁啊，再说我就是干这个，这个我也有，console是个内置对象，给你。 引擎：么么哒。我得看看这里面是不是有log(···)，太好了，找到了，是个函数。 引擎：哥们，你能在帮我找找对a的RHS引用吗？虽然我记得它，但是我想再确认一下。 作用域：放心吧，这个变量没有动过，拿走，不谢。 引擎：真棒！我来把a的值，也就是2传递进log(..) ······","categories":[],"tags":[]},{"title":"如何使用命令行快速打开sublime编辑器","slug":"如何使用命令行快速打开sublime编辑器","date":"2017-02-01T01:59:38.000Z","updated":"2017-09-01T05:37:04.000Z","comments":true,"path":"2017/02/01/如何使用命令行快速打开sublime编辑器/","link":"","permalink":"http://yoursite.com/2017/02/01/如何使用命令行快速打开sublime编辑器/","excerpt":"","text":"版权声明：本文为博主原创文章，未经博主允许不得转载。 建立软链： sudo ln -s /Applications/Sublime\\ Text\\ 2.app/Contents/SharedSupport/bin/subl /usr/local/bin/sublime 然后就可以用sublime命令打开文件了 sublime hello.txt sublime –help列出subl的常用命令集 –project : Load the given project –command : Run the given command -n or –new-window: Open a new window -a or –add: Add folders to the current window -w or –wait: Wait for the files to be closed before returning -b or –background: Don’t activate the application -s or –stay: Keep the application activated after closing the file -h or –help: Show help (this message) and exit -v or –version: Show version and exit sublime 文件名使用sublime打开文件 sublime -n 文件名以新窗口打开文件 sublime -a 文件夹名将当前文件夹添加到sublime当前窗口中 sublime -n 文件夹名将当前文件夹添加到sublime的新窗口中","categories":[],"tags":[]},{"title":"上传到github仓库，并在线浏览网页","slug":"putingithub","date":"2017-01-04T08:36:27.000Z","updated":"2017-11-03T03:28:09.000Z","comments":true,"path":"2017/01/04/putingithub/","link":"","permalink":"http://yoursite.com/2017/01/04/putingithub/","excerpt":"","text":"版权声明：本文为博主原创文章，未经博主允许不得转载。 第一步：首先准备好你需要上传的文件夹，里面有你写好的html、js和css文件等在账号下创建一个仓库，名字为into来到你的目录下 此时已经进入文件夹，输入 git add index.html git add style.css git add render.js git commit -m &quot;first commit&quot; git remote add origin git@github.com:yourname/intro. git git push -u origin master 之后显示 Counting objects: 4, done. Delta compression using up to 4 threads. Compressing objects: 100% (4/4), done. Writing objects: 100% (4/4), 30.90 KiB | 0 bytes/s, done. Total 4 (delta 0), reused 0 (delta 0) * [new branch] master -&gt; master Branch master set up to track remote branch master from origin. 就可以了，返回到你的仓库里，就可以看到了 第二步：在个人的github上找到setting设置按钮 第三步：最后复制地址访问就ok了","categories":[],"tags":[]},{"title":"ajax","slug":"ajax","date":"2016-10-19T12:18:54.000Z","updated":"2017-09-05T01:18:39.000Z","comments":true,"path":"2016/10/19/ajax/","link":"","permalink":"http://yoursite.com/2016/10/19/ajax/","excerpt":"","text":"版权声明：本文为博主原创文章，未经博主允许不得转载。 在学习之前，您需要对下面的知识有基本的了解：HTML / XHTMLCSSJavaScript / DOM 什么是 AJAX ？AJAX = 异步 JavaScript 和 XML。AJAX 是一种用于创建快速动态网页的技术。通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用 AJAX）如果需要更新内容，必需重载整个网页面。有很多使用 AJAX 的应用程序案例：新浪微博、Google 地图、开心网等等。 创建 XMLHttpRequest 对象XMLHttpRequest 用于在后台与服务器交换数据。创建 XMLHttpRequest 对象的语法：variable=new XMLHttpRequest();老版本的 Internet Explorer （IE5 和 IE6）使用 ActiveX 对象：variable=new ActiveXObject(“Microsoft.XMLHTTP”); var xmlhttp; if (window.XMLHttpRequest){// code for IE7+, Firefox, Chrome, Opera, Safari xmlhttp=new XMLHttpRequest(); }else{// code for IE6, IE5 xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); } 向服务器发送请求如需将请求发送到服务器，我们使用 XMLHttpRequest 对象的 open() 和 send() 方法：xmlhttp.open(“GET”,”test1.txt”,true);xmlhttp.send();方法 描述open(method,url,async)规定请求的类型、URL 以及是否异步处理请求。method：请求的类型；GET 或 POSTurl：文件在服务器上的位置async：true（异步）或 false（同步）send(string)将请求发送到服务器。string：仅用于 POST 请求 GET 还是 POST？与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。然而，在以下情况中，请使用 POST 请求：无法使用缓存文件（更新服务器上的文件或数据库）向服务器发送大量数据（POST 没有数据量限制）发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠 为了缓存情况，请向 URL 添加一个唯一的 IDxmlhttp.open(“GET”,”demo_get.asp?t=” + Math.random(),true);xmlhttp.send();如果需要像 HTML 表单那样 POST 数据，请使用 setRequestHeader() 来添加 HTTP 头。然后在 send() 方法中规定您希望发送的数据：xmlhttp.open(“POST”,”ajax_test.asp”,true);xmlhttp.setRequestHeader(“Content-type”,”application/x-www-form-urlencoded”);xmlhttp.send(“fname=Bill&amp;lname=Gates”); onreadystatechange 事件当请求被发送到服务器时，我们需要执行一些基于响应的任务。每当 readyState 改变时，就会触发 onreadystatechange 事件。readyState 属性存有 XMLHttpRequest 的状态信息。onreadystatechange 存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。readyState存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。0: 请求未初始化1: 服务器连接已建立2: 请求已接收3: 请求处理中4: 请求已完成，且响应已就绪status200: “OK”404: 未找到页面 xmlhttp.onreadystatechange=function(){ if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200){ document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText; } } 完整的实例var xmlhttp; function loadXMLDoc(url,cfunc){ if (window.XMLHttpRequest){// code for IE7+, Firefox, Chrome, Opera, Safari xmlhttp=new XMLHttpRequest(); }else{// code for IE6, IE5 xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); } xmlhttp.onreadystatechange=cfunc; xmlhttp.open(&quot;GET&quot;,url,true); xmlhttp.send(); } function myFunction(){ loadXMLDoc(&quot;/ajax/test1.txt&quot;,function(){ if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200){ document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText; } }); }","categories":[],"tags":[]},{"title":"React入门","slug":"React入门","date":"2016-09-10T13:27:12.000Z","updated":"2017-08-30T07:33:56.000Z","comments":true,"path":"2016/09/10/React入门/","link":"","permalink":"http://yoursite.com/2016/09/10/React入门/","excerpt":"","text":"前置知识1.JS，CSS基础2.Sass，Compass3.Yeoman，Grunt，Webpack4.CommonJS，NodeJS5.Git，Github JSXJSX字面上的意思就是javascript和xml，是facebook为react 框架开发的一套语法糖。｛解析js的表达式｝需要解析库解析，最终被解析成JS。type为text/jsx。 html只有个根元素，div id=”container”。 css声明类名改为className，内联样式style＝｛｛color：‘red’｝｝。","categories":[],"tags":[]},{"title":"HEXO+github,搭建属于自己的博客","slug":"HEXO-github-搭建属于自己的博客","date":"2016-09-06T13:34:18.000Z","updated":"2017-09-05T01:01:42.000Z","comments":true,"path":"2016/09/06/HEXO-github-搭建属于自己的博客/","link":"","permalink":"http://yoursite.com/2016/09/06/HEXO-github-搭建属于自己的博客/","excerpt":"","text":"hexo是一款基于Node.js的静态博客框架,hexo github链接,这篇教程是针对与Mac的.之前是想着写博客，一方面是给自己做笔记，可以提升自己的写作、总结能力，一个技术点我们会使用，并不难，但是要做到让让别人也能听懂我们讲得，还是需要一定的技巧和经验的。很多类似于CSDN、博客园也都可以写文章，但是页面的样式我，不是太喜欢，简书还算好点得。最近看到一些大神们的博客,貌似都是用hexo写得,我也依葫芦画瓢的搭建了一个。不罗嗦了，直接上搭建步骤。 配置环境安装Node（必须）作用：用来生成静态页面的到Node.js官网下载相应平台的最新版本，一路安装即可。 安装Git（必须）作用：把本地的hexo内容提交到github上去.安装Xcode就自带有Git，我就不多说了。 申请GitHub（必须）作用：是用来做博客的远程创库、域名、服务器之类的，怎么与本地hexo建立连接等下讲。github账号我也不再啰嗦了,没有的话直接申请就行了，跟一般的注册账号差不多，SSH Keys，看你自己了，可以不配制，不配置的话以后每次对自己的博客有改动提交的时候就要手动输入账号密码，配置了就不需要了，怎么配置我就不多说了，网上有很多教程。 正式安装HexoNode和Git都安装好后,首先创建一个文件夹,如blog,用户存放hexo的配置文件,然后进入blog里安装Hexo。执行如下命令安装Hexo：进入blog文件夹内 npm install hexo-cli -g npm install hexo-deployer-git --save hexo g hexo d hexo init hexo g hexo s 然后用浏览器访问http://localhost:4000/，此时，你应该看到了一个漂亮的博客了，当然这个博客只是在本地的，别人是看不到的，hexo3.0使用的默认主题是landscape。轻轻松松就看到了一点成果，是不是很激动，这就是hexo的强大之处，这个本地预览的功能，我真是爱不释手 配置Github建立Repository建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】，固定写法 然后建立关联，blog是我之前建的东西也全在这里面，有： _config.yml node_modules public source db.json package.json scaffolds themes 现在我们需要_config.yml文件，来建立关联，进入blog下的_config.yml文件，打开文件，deploy: type: git repo: https://github.com/your_user_name/your_user_name.github.io.git branch: master 然后执行命令： npm install hexo-deployer-git --save 然后，执行配置命令： hexo deploy 然后再浏览器中输入http://your_user_name.github.io/就行了.","categories":[],"tags":[]}]}